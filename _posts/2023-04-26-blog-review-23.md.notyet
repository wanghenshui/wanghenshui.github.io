---
layout: post
title: blog review 第二十三期
categories: [review]
tags: [doris,scd,sql,mq,vsr]
---
最近感悟

为什么他能想到我想不到，是我笨吗，睡眠不足导致智力下降了？我需要休息一年吗？

有时候感觉左眼不是很舒服，感觉是总看屏幕左边看的

同龄人已经都飞黄腾达了，我还是原地踏步，仔细想来，今年刷手机的频率明显比前几年高了，手机也离眼睛越来越近了。

手机成瘾症，我给自己的手机设置了使用时间限制，根本没用，拦不住玩手机的冲动

睡觉前还要玩一个小时手机，脑子总是兴奋状态，嘻嘻哈哈的状态。不看其实也没啥事，就是忍不住想看。然后还主动去刷，去找乐子。感觉明显是上瘾了。

感觉得返璞归真一下，买个辣鸡手机，打开微信都卡的，控制玩手机的欲望

<!-- more -->

---
## [doris案例集](https://selectdb.feishu.cn/docx/doxcnm0uTBWFTc4Qn9A1WHuqrcg)

很丰富，长了见识

## [缓慢变化维度的处理](https://zhuanlan.zhihu.com/p/345881522)

Slowly Changing Dimension https://en.wikipedia.org/wiki/Slowly_changing_dimension

增加列，增加列属性，增加历史表，感觉不如mongo

我是看这个 [So you want Slowly Changing Dimension?](https://www.dolthub.com/blog/2023-06-22-slowly-changing-dimension/) 了解到的

有点版本的感觉。麻烦

## [消息队列设计精要](https://zhuanlan.zhihu.com/p/21649950)

文章写的很好

## [Software Performance and Class Layout](https://johnnysswlab.com/software-performance-and-class-layout/?utm_source=feedly&utm_medium=rss&utm_campaign=software-performance-and-class-layout)

这哥们的博客我准备翻一遍


这个讲的是局部性问题

比如

```c++
class my_class {
   int a;
   int b;
   ...
   int z;
};
int sum_all(my_class* m, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m[i].a + m[i].z;
    }
    return sum;
}
```

循环用到了a和z，那么a和z就应该靠近点

```cpp
class my_class {
   int a;
   int z;
   int b;
   ...
};
```

用不到的拆出来

```cpp
class my_class {
   int m1;
   int m2;
   int m3;
};
int sum_all(my_class* m, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m[i].m1 + m[i].m2;
    }
    return sum;
}
```

没用到m3，那就把它拿出来

```cpp
class my_class_base {
   int m1;
   int m2;
};
class my_class_aux {
   int m3;
};
int sum_all(my_class_base* m, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m[i].m1 + m[i].m2;
    }
    return sum;
}
```

同理，如果两个类有互相使用，就放在一起

```cpp
class my_class1 {
    int m1;
    int m2;
};
class my_class2 {
    int a1;
    int a2;
}
int sum_all(my_class1* m1, my_class2* m2, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m1[i].m1 + m1[i].m2 + m2[i].a1;
    }
    return sum;
}
```

改成 
```cpp
class my_class1 {
    int m1;
    int m2;
    int a1;
};
class my_class2 {
    int a2;
};
int sum_all(my_class1* m1, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m1[i].m1 + m1[i].m2 + m1[i].a1;
    }
    return sum;
}
```

不要循环中访问指针
```cpp
class my_class {
   int m1;
   int* p_a1;
};
int sum_all(my_class* m, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m[i].m1 + *m[i].p_a1;
    }
    return sum;
}
```

这个pa1非常不合理，应该改成值

再比如这种猥琐的公用

```cpp
class shared {
    int a1;
};
class my_class_1 {
   int m1;
   shared* s;
};
class my_class_2 {
   int m1;
   shared* s;
};
int sum_all_1(my_class_1* m, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m[i].m1 + m[i].s->a1;
    }
    return sum;
}
int sum_all_2(my_class_2* m, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m[i].m1 + m[i].s->a1;
    }
    return sum;
}
```

更新s省事了但是实际上循环访问低效，也得改成值

Structure Of Arrays (SOA)结构体数组改成数组结构体

把数据集改小，比如
```cpp
class big_class {
   int index;
   ...
};
void my_sort(std::vector<big_class>& v) {
    std::sort(v.begin(), v.end(), [](const big_class& l, const big_class& r) { return l.index < r.index; });
}
```

一堆不相关的数据参与了数据加载，可以改成这个
```cpp
class small_class {
    int index;
    int pointer;
};
void my_sort(std::vector<big_class>& v) {
    std::vector<small_class> tmp;
    tmp.reserve(v.size());
    for (int i = 0; i < v.size(); i++) {
        tmp.push_back({v[i].index, i});
    }
    std::sort(tmp.begin(), tmp.end(), [](const small_class& l, const small_class& r) { return l.index < r.index; });
    std::vector<big_class> result;
    result.reserve(tmp.size());
    for (int i = 0; i < tmp.size(); i++) {
        result.push_back(v[tmp[i].index]);
    }
    v = std::move(result);
}
```

这种改法得测量一下，未必有收益，可能有，但不多，主要取决于数据结构，只要bigclass比smallclass大很多的话，收益肯定是有的

## [ViewStamped replication revisited](https://zhuanlan.zhihu.com/p/66984202)
[Viewstamped Replication Revisited简要翻译](https://zhuanlan.zhihu.com/p/66427412)

整的挺好，我画个图联系一下mermaid

正常流程

{% include_relative mermaid.html source="mmd/vr.mmd" %}

选举

{% include_relative mermaid.html source="mmd/vr-vc.mmd" %}

故障恢复

{% include_relative mermaid.html source="mmd/vr-rc.mmd" %}

需要优化的点

- 文件同步根据log会很慢，-> 根据checkpoint同步
- 增加witness
- 批量提交batching
- 引入lease，主读
- 忽略读到旧数据，可以读备

重新上下架的流程我没写

## innodb ReadView https://zhuanlan.zhihu.com/p/642981673

这周看到两次了，画个图

{% include_relative mermaid.html source="mmd/inno-readview.mmd" %}

本质是基于窗口的检查，而不是实际commit的时间戳

引自seven

>
> （1）当记录的 txn_id 等于当前事务id（txn_id = creator_txn_id）时，说明版本链中的这个版本是当前事务修改的，所以该记录对当前事务可见；
> 
> （2）txn_id < min_txn_id，说明版本链中的这条记录已经提交了，所以该快照记录对当前事务可见；
> 
> （3）txn_id > max_txn_id，说明这条记录是当前事务启动后启动的新事务，该记录对当前事务不可见。
> 
> （4）min_txn_id <= txn_id < max_txn_id，首先比较txn_id是否在m_ids 数组中，如果不在说明当前事务开启之前，txn_id对应的事务就将数据修改并提交，所以该记录行的修改对当前事务可见。其次，如果txn_id在m_ids中，说明txn_id对应的事务是和当前事务同时启动的，所以该记录行的修改对当前事务不可见。
> 
> RR和RC的区别在于，对于RR在事务启动的时候即生产了可见性视图（ReadView），同一事物中的select都复用事务开启时的可见性视图。而对于RC隔离级别来说，每次select都会生成一个新的ReadView来进行可见性判断。
>

分布式mysql需要做的就是把txn-id和全局GTS时序绑定

不过其他DB的实现已经脱离txn-id直接用timestamp了。也得有个时间窗吧？
## libgavran

写的挺好，数据库学习入门

这里标记个TODO

https://github.com/ayende/libgavran


## [Modeling Polymorphic Associations in a Relational Database](https://hashrocket.com/blog/posts/modeling-polymorphic-associations-in-a-relational-database)

原来的表

```sql
create table acl(
  id serial primary key,
  resource_type varchar not null,
  resource_id integer not null,
  -- other fields omitted
  unique(resource_id, resource_type)
);
select *
from acl
where resource_type='document'
  and resource_id=42;
```

问题，resource_type没有限制。给个星星设计，加限制

```sql

create table acl_document(
  acl_id integer not null unique references acl,
  document_id integer not unique null references document
);

create table acl_image(
  acl_id integer not null unique references acl,
  image_id integer not null unique references image
);

select acl.*
from acl
  join acl_document on acl_document.acl_id=acl.id
where document_id=42;


create table acl(
  id serial primary key,
  document_id integer references document,
  image_id integer references image,
  file_id integer references file,
  report_id integer references report,
  -- other fields omitted
  check(
    (
      (document_id is not null)::integer +
      (image_id is not null)::integer +
      (file_id is not null)::integer +
      (report_id is not null)::integer 
    ) = 1
  )
);

create unique index on acl (document_id) where document_id is not null;
create unique index on acl (image_id) where image_id is not null;
create unique index on acl (file_id) where file_id is not null;
create unique index on acl (report_id) where report_id is not null;
```

清晰，就是麻烦