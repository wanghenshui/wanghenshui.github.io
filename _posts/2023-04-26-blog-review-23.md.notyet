---
layout: post
title: blog review 第二十三期
categories: [review]
tags: [doris,scd,sql,mq,vsr,starrock,neon,epoll,bpf,perf,scylladb,tum,innodb]
---
最近感悟

为什么他能想到我想不到，是我笨吗，睡眠不足导致智力下降了？我需要休息一年吗？

有时候感觉左眼不是很舒服，感觉是总看屏幕左边看的

同龄人已经都飞黄腾达了，我还是原地踏步，仔细想来，今年刷手机的频率明显比前几年高了，手机也离眼睛越来越近了。

手机成瘾症，我给自己的手机设置了使用时间限制，根本没用，拦不住玩手机的冲动

睡觉前还要玩一个小时手机，脑子总是兴奋状态，嘻嘻哈哈的状态。不看其实也没啥事，就是忍不住想看。然后还主动去刷，去找乐子。感觉明显是上瘾了。

感觉得返璞归真一下，买个辣鸡手机，打开微信都卡的，控制玩手机的欲望

<!-- more -->

---
## [doris案例集](https://selectdb.feishu.cn/docx/doxcnm0uTBWFTc4Qn9A1WHuqrcg)

很丰富，长了见识

## [缓慢变化维度的处理](https://zhuanlan.zhihu.com/p/345881522)

Slowly Changing Dimension https://en.wikipedia.org/wiki/Slowly_changing_dimension

增加列，增加列属性，增加历史表，感觉不如mongo

我是看这个 [So you want Slowly Changing Dimension?](https://www.dolthub.com/blog/2023-06-22-slowly-changing-dimension/) 了解到的

有点版本的感觉。麻烦

## [消息队列设计精要](https://zhuanlan.zhihu.com/p/21649950)

文章写的很好

## [Software Performance and Class Layout](https://johnnysswlab.com/software-performance-and-class-layout/?utm_source=feedly&utm_medium=rss&utm_campaign=software-performance-and-class-layout)

这哥们的博客我准备翻一遍


这个讲的是局部性问题

比如

```c++
class my_class {
   int a;
   int b;
   ...
   int z;
};
int sum_all(my_class* m, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m[i].a + m[i].z;
    }
    return sum;
}
```

循环用到了a和z，那么a和z就应该靠近点

```cpp
class my_class {
   int a;
   int z;
   int b;
   ...
};
```

用不到的拆出来

```cpp
class my_class {
   int m1;
   int m2;
   int m3;
};
int sum_all(my_class* m, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m[i].m1 + m[i].m2;
    }
    return sum;
}
```

没用到m3，那就把它拿出来

```cpp
class my_class_base {
   int m1;
   int m2;
};
class my_class_aux {
   int m3;
};
int sum_all(my_class_base* m, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m[i].m1 + m[i].m2;
    }
    return sum;
}
```

同理，如果两个类有互相使用，就放在一起

```cpp
class my_class1 {
    int m1;
    int m2;
};
class my_class2 {
    int a1;
    int a2;
}
int sum_all(my_class1* m1, my_class2* m2, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m1[i].m1 + m1[i].m2 + m2[i].a1;
    }
    return sum;
}
```

改成 
```cpp
class my_class1 {
    int m1;
    int m2;
    int a1;
};
class my_class2 {
    int a2;
};
int sum_all(my_class1* m1, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m1[i].m1 + m1[i].m2 + m1[i].a1;
    }
    return sum;
}
```

不要循环中访问指针
```cpp
class my_class {
   int m1;
   int* p_a1;
};
int sum_all(my_class* m, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m[i].m1 + *m[i].p_a1;
    }
    return sum;
}
```

这个pa1非常不合理，应该改成值

再比如这种猥琐的公用

```cpp
class shared {
    int a1;
};
class my_class_1 {
   int m1;
   shared* s;
};
class my_class_2 {
   int m1;
   shared* s;
};
int sum_all_1(my_class_1* m, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m[i].m1 + m[i].s->a1;
    }
    return sum;
}
int sum_all_2(my_class_2* m, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += m[i].m1 + m[i].s->a1;
    }
    return sum;
}
```

更新s省事了但是实际上循环访问低效，也得改成值

Structure Of Arrays (SOA)结构体数组改成数组结构体

把数据集改小，比如
```cpp
class big_class {
   int index;
   ...
};
void my_sort(std::vector<big_class>& v) {
    std::sort(v.begin(), v.end(), [](const big_class& l, const big_class& r) { return l.index < r.index; });
}
```

一堆不相关的数据参与了数据加载，可以改成这个
```cpp
class small_class {
    int index;
    int pointer;
};
void my_sort(std::vector<big_class>& v) {
    std::vector<small_class> tmp;
    tmp.reserve(v.size());
    for (int i = 0; i < v.size(); i++) {
        tmp.push_back({v[i].index, i});
    }
    std::sort(tmp.begin(), tmp.end(), [](const small_class& l, const small_class& r) { return l.index < r.index; });
    std::vector<big_class> result;
    result.reserve(tmp.size());
    for (int i = 0; i < tmp.size(); i++) {
        result.push_back(v[tmp[i].index]);
    }
    v = std::move(result);
}
```

这种改法得测量一下，未必有收益，可能有，但不多，主要取决于数据结构，只要bigclass比smallclass大很多的话，收益肯定是有的

## [ViewStamped replication revisited](https://zhuanlan.zhihu.com/p/66984202)
[Viewstamped Replication Revisited简要翻译](https://zhuanlan.zhihu.com/p/66427412)

整的挺好，我画个图联系一下mermaid

正常流程

{% include_relative mermaid.html source="mmd/vr.mmd" %}

选举

{% include_relative mermaid.html source="mmd/vr-vc.mmd" %}

故障恢复

{% include_relative mermaid.html source="mmd/vr-rc.mmd" %}

需要优化的点

- 文件同步根据log会很慢，-> 根据checkpoint同步
- 增加witness
- 批量提交batching
- 引入lease，主读
- 忽略读到旧数据，可以读备

重新上下架的流程我没写

## innodb ReadView https://zhuanlan.zhihu.com/p/642981673

这周看到两次了，画个图

{% include_relative mermaid.html source="mmd/inno-readview.mmd" %}

本质是基于窗口的检查，而不是实际commit的时间戳

引自seven

>
> （1）当记录的 txn_id 等于当前事务id（txn_id = creator_txn_id）时，说明版本链中的这个版本是当前事务修改的，所以该记录对当前事务可见；
> 
> （2）txn_id < min_txn_id，说明版本链中的这条记录已经提交了，所以该快照记录对当前事务可见；
> 
> （3）txn_id > max_txn_id，说明这条记录是当前事务启动后启动的新事务，该记录对当前事务不可见。
> 
> （4）min_txn_id <= txn_id < max_txn_id，首先比较txn_id是否在m_ids 数组中，如果不在说明当前事务开启之前，txn_id对应的事务就将数据修改并提交，所以该记录行的修改对当前事务可见。其次，如果txn_id在m_ids中，说明txn_id对应的事务是和当前事务同时启动的，所以该记录行的修改对当前事务不可见。
> 
> RR和RC的区别在于，对于RR在事务启动的时候即生产了可见性视图（ReadView），同一事物中的select都复用事务开启时的可见性视图。而对于RC隔离级别来说，每次select都会生成一个新的ReadView来进行可见性判断。
>

分布式mysql需要做的就是把txn-id和全局GTS时序绑定

不过其他DB的实现已经脱离txn-id直接用timestamp了。也得有个时间窗吧？
## libgavran

写的挺好，数据库学习入门

这里标记个TODO

https://github.com/ayende/libgavran


## [Modeling Polymorphic Associations in a Relational Database](https://hashrocket.com/blog/posts/modeling-polymorphic-associations-in-a-relational-database)

原来的表

```sql
create table acl(
  id serial primary key,
  resource_type varchar not null,
  resource_id integer not null,
  -- other fields omitted
  unique(resource_id, resource_type)
);
select *
from acl
where resource_type='document'
  and resource_id=42;
```

问题，resource_type没有限制。给个星星设计，加限制

```sql

create table acl_document(
  acl_id integer not null unique references acl,
  document_id integer not unique null references document
);

create table acl_image(
  acl_id integer not null unique references acl,
  image_id integer not null unique references image
);

select acl.*
from acl
  join acl_document on acl_document.acl_id=acl.id
where document_id=42;


create table acl(
  id serial primary key,
  document_id integer references document,
  image_id integer references image,
  file_id integer references file,
  report_id integer references report,
  -- other fields omitted
  check(
    (
      (document_id is not null)::integer +
      (image_id is not null)::integer +
      (file_id is not null)::integer +
      (report_id is not null)::integer 
    ) = 1
  )
);

create unique index on acl (document_id) where document_id is not null;
create unique index on acl (image_id) where image_id is not null;
create unique index on acl (file_id) where file_id is not null;
create unique index on acl (report_id) where report_id is not null;
```

清晰，就是麻烦


## [The C++ Type Loophole (C++14)](https://alexpolt.github.io/type-loophole.html)

经典的友元函数注入

```cpp
template<int N> struct tag{};

template<typename T, int N>
struct loophole_t {
  friend auto loophole(tag<N>) { return T{}; };
};

auto loophole(tag<0>);

sizeof(loophole_t<std::string, 0> );

statc_assert(std::is_same< std::string, decltype( loophole(tag<0>{}) ) >::value,"same");
```

这玩意属于缺陷，说不定以后就修了

## [StarRocks 源码解析](https://www.zhihu.com/column/c_1595736761170358272)

挺不错

https://blog.bcmeng.com/post/starrocks-source-code-1.html

这哥们总结的很好 https://blog.bcmeng.com/post/starrocks-source-code-1.html

还有这个 https://blog.bcmeng.com/post/dpa.html

https://blog.bcmeng.com/post/dpa.html
https://blog.bcmeng.com/post/starrocks-look-up.html

## BPF工具分析

系统调用分析

```bash
./syscount -t xxx -i 1 -L
perf trace -t xxx -e syscalls:sys_enter_* -- sleep 600 > perf_trace.txt
bpftrace -e 't:syscalls:sys_enter_epoll_wait /comm == "spp_call_center"/ { @[comm, pid, tid] = hist(args->timeout); } i:s:1 { time(); print(@); clear(@); }'

bpftrace -e 't:syscalls:sys_enter_epoll_wait /tid == xxx/ { @ = hist(args->timeout); } i:s:1 { time(); print(@); clear(@); } i:s:600 { exit(); }'
```

epoll_wait timeout 参数动态优化 是一个关注点，根据业务的经验值来调整
- 如何统计？每次加一个时间点，同时排序 -> 堆排
- 根据每个任务index保存自己的时间（需要有个时间标准，这玩意不能太慢，不然成瓶颈了），然后计算这个超时时间，最大10ms，每次epoll_wait设置一次

哪个好？第一个通用，第二个具体，但可能涉及时间调用gettimeofday？
得缓存一下，比如一个后台线程周期更新存tls里，epoll_wait设置这个时间点时候直接读tls对象，加一层避免直接系统调用
## [Comparing Queuing Strategies in Distributed Systems](https://fsck.ai/labs/queuing)

这个图挺直观

## [Linux删除文件过程解析](https://www.cnblogs.com/lwyeric/p/13603959.html)

删除文件可能有大量inode操作，如果删除的大文件影响更严重，如何缓慢删除？看这个9SO](https://serverfault.com/questions/814029/how-can-i-slowly-delete-a-large-directory-hiearachy-to-reduce-disk-i-o-load)

```bash
ionice -c3 rm -rf $NAME
```

但是程序里用的是fs::remove接口，这种有办法放慢吗？只能手写遍历，删一个sleep一下？

## [Kudu: Storage for Fast Analytics on Fast Data](https://zhuanlan.zhihu.com/p/492151665)

列存+行存

## gap buffer

就是长一点的buffer，文本编辑器用

一个实现 https://github.com/lazyhacker/gapbuffer/blob/master/gap_buffer.h


## FSST: Fast Random Access String Compression

也是字典压缩～ https://raw.githubusercontent.com/cwida/fsst/master/fsstcompression.pdf

优点在于构造的字典，是根据数据来构造的，不是全局的，能更优秀

针对单条压缩，非二进制数据（json xml网址邮箱）有优势。值得测一测。这个玩意是TUM的论文

chatgpt老师 的总结

> FSST是一种字符串压缩算法，它利用列中经常出现的子字符串进行压缩。该算法的关键实现细节包括： 1. 基本思想：FSST通过将长度为1-8的子字符串替换为1字节的编码来实现快速而有效的字符串压缩。 2. 符号表构建：FSST使用一种基于遗传算法的自底向上的方法来构建符号表。该算法能够根据给定的数据集找到一个好的符号表。 3. 压缩速度优化：为了使压缩过程更快速，FSST利用了AVX512 SIMD指令集等技术。 4. 解压缩速度：FSST提供快速的解压缩算法，平均每字节2个周期（或每核心1 GB/秒）的解压缩速度。 5. 随机访问能力：与LZ4相比，FSST支持有效的随机访问，即能够在不解压缩数据块的情况下访问个别字符串。这使得FSST在数据库系统等应用中特别有用。 总之，FSST通过优化符号表构建、压缩速度和解压缩速度等方面的实现细节，实现了快速、高效的字符串压缩，并能够支持随机访问能力。
>
>
## [How ScyllaDB Distributed Aggregates Reduce Query Execution Time up to 20](https://www.scylladb.com/2023/06/20/how-scylladb-distributed-aggregates-reduce-query-execution-time-up-to-20x/)

就是计算均摊，类似count minmax这种，可以MPP。感觉就是OLAP的技术拿过来用一用，一个协调者调度节点计算收集数据
## neondb

怎么share log？


## openai老师 https://openaikey.xyz/